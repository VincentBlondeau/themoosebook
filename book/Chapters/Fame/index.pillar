!Meta-modeling with FameFame is the meta-modeling infrastructure of Moose. It provides the following features:- the FM3 self described meta-meta-model,- meta-description of regular implementation classes through annotations,- the MSE format for model interchange,- input/output serialization to the MSE format, and- generation of implementation classes from a meta-description.!!The FM3 meta-meta-modelThe core of Fame is given by the FM3 meta-meta-model. FM3 is a small meta-meta-model inspired from the Essential Meta-Object Facility.All meta-models from Moose are described in terms of FM3.More information about it can be found at: *http://www.moosetechnology.org/tools/fame/*!!Subject, model, meta-model, meta-meta-modelOften, the terms of model and meta-model generate confusion. As they are crucial for understanding the terminology related to modeling, let me spend a couple of words to clarify them.Before talking about either of them, we first have to talk about the concept of a ''subject''. A subject is simply something we want to reason about. It can be something from the real world, or something imaginary. For example, if we want to analyze a software system, that software system is the subject.The act of reasoning is typically geared around one specific problem or question. The answer to the question typically only concerns a small subset of all the characteristics of the subject. Thus, the process of reasoning is greatly enhanced if we limit its scope to only the relevant variables.For example, when we want to reason about the best path to get from point A to point B, we only require the route information, and we do not really need to know about other details like the quantity of oil in the ground, or the language spoken by the inhabitants. This is why for the purpose of route finding, we typically use a travel map which is a great tool that provides exactly the details we need to solve our little problem.In general, to solve a problem we construct simplifications of the subject. We call these models. Bezivin and Gerbe define a model: a simplification of the subject, and its purpose is to answer some particular questions aimed towards the subject. In the case of Moose, FAMIX (see *ref:../../famix*) is a family of meta-models for representing the structure of software projects.Given that a model captures only a part of the complete subject, we can build many models that represent the same subject but that capture different variables of the subject. To reason about a model we need to know which exact variables it offers. In other words, we need to know the structure of the model. This information is expressed in the meta-model, where a meta-model is a model that makes statements about what can be expressed in valid models.One common misconception is to say that ''a meta-model is the model of a model''. That is incorrect. A model shows a simplification of a subject. A meta-model offers the vocabulary for formulating reasonings on top of a given model. While both are models, they are different in intent and interpretation.Another form of the above misconception is formulated as: ''the relationship between the model and subject is the same as the one between meta-model and model''. That is incorrect as well. While a model ''represents'' a subject, a meta-model ''describes'' a model.Once we understand the difference between meta-model and model, we can go even deeper in the meta-land and add as many meta levels as we might need. The attached diagram shows an overall of four levels and their relationships.+Subject, model, meta-model, meta-meta-model>file://figures/subject-model-meta-model-meta-meta-model.png+Why would we need more meta-levels? We always need a meta-level when we want to reason about the model at the level below. When we want to reason about a map, we need to know its structure. In the same way, when we want to reason about the structure of a map, we need to know the structure of the structure of the map. In Moose, we have a main meta-meta-model in terms of which we describe our meta-models: FM3 (see *ref:../*).!!Pharo integration@@todo more[[[FAMIXPackage new class "--> FAMIXPackage"]]][[[FAMIXPackage mooseDescription "-->  a FM3MetaDescription[FAMIX.Package]"]]][[[FAMIXPackage new mooseDescription "-->  a FM3MetaDescription[FAMIX.Package]"]]][[[FAMIXPackage new mooseDescription implementingClass "--> FAMIXPackage"]]]+Fame integration with the Pharo meta-model>file://figures/fame-pharo-integration.png+[[[FAMIXPackage asMooseDescription attributes first implementingSelector "--> #numberOfMethods"]]]- ==Object>>mmGetProperty: aFM3PropertyDescription==- ==Object>>mmSetProperty: aFM3PropertyDescription to: value==-----------------------------Just thown this here for know- FMMultivalueLinkUsed to create 1 to n links between famix elements. Example with inheritance where a FAMIXInheritance has a link to 1 FAMIXType and where FAMIXType have 1 link to n  FAMIXInheritances:In FAMIXInheritance (subclass is an instance variable):[[[FAMIXInheritance >>subclass	<MSEProperty: #subclass type: #FAMIXType opposite: #superInheritances>	<MSEComment: 'Subclass linked to in this relationship. from-side of the association'>	^subclass]]][[[     FAMIXInheritance >> subclass: aType          subclass := FMMultivalueLink on: self                                update: #superInheritances                                from: self subclass                                to: aType]]]In: FAMIXType (superInheritances is an instance variable)[[[FAMIXType >>initialize	superInheritances := FMNullMultivalueLink on: self opposite: #subclass: selector: #superInheritances.]]][[[FAMIXType >>superInheritances	<MSEProperty: #superInheritances type: #FAMIXInheritance opposite: #subclass> <multivalued> <derived>	<MSEComment: 'Superinheritance relationships, i.e. known superclasses of this type.'>	^superInheritances]]][[[FAMIXType >> superInheritances: anInheritance	superInheritances value: anInheritance]]]_______________________________________-  FMMultiMultivalueLink. To create n to n associations. Example:In FAMIXInvocations (candidates is an instance variable):[[[FAMIXInvocations >> initialize          candidates := FMMultiMultivalueLink on: self opposite: #incomingInvocations.]]][[[FAMIXInvocations >> candidates          <MSEProperty: #candidates type: #FAMIXBehaviouralEntity opposite: #incomingInvocations> <multivalued>          <MSEComment: 'List of candidate behavioural entities for receiving the invocation'>               ^candidates]]][[[     FAMIXInvocations >> candidates: aCollection           candidates value: aCollection]]]In FAMIXBehaviouralEntity  (incomingInvocations is an instance variable):[[[     FAMIXBehaviouralEntity  >> initialize          incomingInvocations := FMMultiMultivalueLink on: self opposite: #candidates.]]][[[FAMIXBehaviouralEntity   >> incomingInvocations          <MSEProperty: #incomingInvocations type: #FAMIXInvocation opposite: #candidates> <multivalued> <derived>          <MSEComment: 'Incoming invocations from other behaviours computed by the candidate operator.'>               ^incomingInvocations]]][[[     FAMIXBehaviouralEntity   >> incomingInvocations: anInvocation          incomingInvocations value: anInvocation]]]________________________________________- FMNullMultivalueLink: used to reduce memory consumption (see other answers) - <multivalued>: used to describe in the meta model that the return value is a collection of entities and no only one entity.- <derived>: as said by Guillaume: “is for things that don't require to be stored in the .mse for example because you can derive it (compute) from other data”Example:[[[numberOfAccesses     <MSEProperty: #numberOfAccesses type: #Number>     <derived>     <MSEComment: 'The number of accesses from a method'>          ^ self            lookUpPropertyNamed: #numberOfAccesses           computedAs: [ self accesses size ]]]]@@todo : add colors in the explainationAll these pragmas are mandatory to describe relations in Fame Meta Meta Model and should be provided accurately.And you should put something like:[[[annotation     <MSEClass: #BehaviouralEntity super: #FAMIXContainerEntity>     <package: #FAMIX>     ^self]]]On class side of your Moose classes to reference them in the meta model.After a change in the pragmas, do : [[[MooseModel resetMeta]]] It avoid a lots of problems ;)